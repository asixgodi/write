/**
 * 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。
 * （注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
 */

// 方法一：使用差值法，让长的链表先走，之后再和短的链表一起走。需要先遍历一遍得到链表的长度
// 方法二：双指针。 假设链表 A 的非公共部分长度为 a，链表 B 的非公共部分长度为 b，公共部分长度为 c。
// 指针 p1 走完 A 链表后，立马跳到 B 链表的头。 指针 p2 走完 B 链表后，立马跳到 A 链表的头。
// 为什么会相遇？
// p1 走的路径：a + c + b
// p2 走的路径：b + c + a
// 结果：a + c + b 等于 b + c + a。他们会在走了相同步数后，同时到达公共节点（或者同时到达 null）
function FindFirstCommonNode(pHead1, pHead2)
{
    let p1 = pHead1
    let p2 = pHead2
    while(p1 !== p2){
        p1 = (p1 === null) ? pHead2:p1.next
        p2 = (p2 === null) ? pHead1:p2.next
    }
    return p1
}