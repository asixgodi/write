/**
 * 给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。
所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。
我们定义一个序列是 严格上升 的
输入：[6,3,1,5,2,3,7]
返回值：4  最长上升子序列是：[1,2,3,7]
要求：时间复杂度 O(n^2)， 空间复杂度 O(n)
 */

// 此题使用动态规划,
// 关键就是要想清楚dp[i]的含义。
// dp[i]的含义是：以当前i下标为终点时的最长递增子序列的长度。为什么是终点：因为这样我就可以从前往后遍历。
// dp[i] = Math.max(dp[i],dp[j]+1)  对于当前位置i，设置一个j，去遍历i之前的所有位置
function LIS( arr ) {
    if(arr.length === 0) return 0
    // 初始化时，可以将dp中的每个元素都设置为1，每个数字本身至少可以构成一个长度为 1 的子序列。
    const dp = new Array(arr.length).fill(1)
    let maxLen = 1
    for(let i = 1;i<arr.length;i++){
        for(j = i-1;j>=0;j--){
            if(arr[i]>arr[j]){
                dp[i] = Math.max(dp[i],dp[j]+1)
            }
        }
        // 每次算完dp[i]就更新局部最大值
        maxLen = Math.max(maxLen,dp[i])
    }
    return maxLen
}
