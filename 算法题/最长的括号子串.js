/**
    给出一个长度为 n 的，仅包含字符 '(' 和 ')' 的字符串，计算最长的格式正确的括号子串的长度。
    例1: 对于字符串 "(()" 来说，最长的格式正确的子串是 "()" ，长度为 2 .
    例2：对于字符串 ")()())" , 来说, 最长的格式正确的子串是 "()()" ，长度为 4 .
 */

// 第二种情况解释:
/**
    (( ))
索引: 0 1 2 3 
当前状态：
    i = 3，字符是 )。
    i - 1 = 2，字符也是 )。
    已知 dp[2] = 2。这代表索引 1 和 2 组成的 () 是有效的，长度为 2。
    跳跃寻找配对：
        既然索引 1-2 是已经闭合的 ()，那我手里的 s[3] 就不能跟它们配对。
        我得跨过这段长度为 2 的区域，去找更前面的那个字符。
        寻找位置公式：匹配位 = 当前位 - 1 - 前面有效长度
        matchIndex = 3 - 1 - dp[2] = 3 - 1 - 2 = 0。 
 */    
// dp[i] 表示以第 i 个字符结尾的最长有效括号子串的长度
function longestValidParentheses( s ) {
    if(!s || s.length === 1) return 0
    // 使用动态规划
    const n = s.length
    const dp = new Array(n).fill(0)
    let max = 0
    for(let i = 1;i<n;i++){
        if(s[i] === ')'){
            // 情况 1: () 即 s[i-1] 是 '('
            if(s[i-1] === '('){
                dp[i] = (i-2>=0 ? dp[i-2] : 0) + 2
            }
            // 情况2,有嵌套的: )) 即 s[i-1] 是 ')' 我们需要跳过 dp[i-1] 代表的这段长度，去看前面的字符
            else if(i-1-dp[i-1]>=0 && s[i-1-dp[i-1]] ==='('){
                // 这个prevValidLen是为了加上更前面已经匹配好的括号长度
                let prevValidLen = (i - dp[i - 1] - 2 >= 0) ? dp[i - dp[i - 1] - 2] : 0;
                dp[i] = dp[i - 1] + 2 + prevValidLen;
            }
            max = Math.max(max, dp[i]);
        }
    }
    return max
}